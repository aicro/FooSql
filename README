***************************
INTRODUCTION
***************************
Why the name is FooSql? Because I do not know how to get the name...  ^_^

This library is specially designed for DB dependent systems in which rollback is trivial, for example a batch system, or softwares running in a tunnel architecture that the corruption results can be regenerated by stored previous computing results. 

The library has simplified coding for operations towards MYSQL and DB2. I have implemented most regular operations with 100% C++ codes and no extra libraries are needed.

There are some supporting library inside, including components as INI parser, Threads and Threads Pools, blocking queues and an exception model.

Note that, the current version is only supported for MYSQL and DB2, but it is easy to expand to other DB.

***************************
BUILD AND INSTALL
***************************
1. Download the project

2. Get into the FooSql.

3. Do the following commands
mkdir build
cd build
cmake CMAKE_INSTALL_PREFIX=<...> .. (or to identify CMAKE_BUILD_EXAMPLES=on to build all examples)
make
make install 

Note that, the MYSQL part will only build under the environment which have MYSQL client library installed, that means the command ¡®mysql_config --variable=pkgincludedir¡¯ must be executed successfully. 
As for DB2, you will have to ensure the DB2 client library is installed, and the DB2HOME can be found correctly.

***************************
BUILD YOUR FIRST PROGRAM
***************************
In order to build your first program with FooSql, you will have to identify the library locations, which may usually in <CMAKE_INSTALL_PREFIX>/lib/FooSql, and include files, usually in <CMAKE_INSTALL_PREFIX>/include/FooSql. 

In your code, the only files to be included are 
#include "dbcomm/DbComm.h"
#include "exception/ThrowableException.h"

The useful namespaces are COMMON::DBCOMM and COMMON::EXCEPTION.

Details can be got from EXAMPLES.

***************************
Getting Started
***************************
Remember, the only steps you will have to do is connect, get corresponding actions, do your job, end that action and disconnect.

1. Connect 
connect to the DB(s).

2. Get Actions
Operations as INSERT, DELETE, MERGE INTO are defined as actions in the library. Before doing a specific job, you will have to identify which action that job belongs to. 

3. Do your job
Using the action, you can do the SQL commands to server(s). The library provides 3 different ways to do the job. 
1)	Send the same SQL commands to all connected DBs identified in the Connect step.
2)	Send one SQL command to one of the DBs identified in the Connect step.
3)	Send different SQL commands to different DBs identified in the Connect step.

All the above are implemented by DbAction::Do methods. Different actions are corresponded with different Filters. The mapping between these two can be found in the example codes. I STRONGLY RECOMMEND YOU TO USE THE LIBRARY BY REFERRING TO THE EXAMPLES.

4. End Action
When generating most actions, a number indicating when to tell the DB to do the commit work is passed. However, in most cases, the commit work may not be done because no enough conditions are met. At this time, the DbAction::EndAction is used to explicitly invoke a commit work towards all connected DBs to ensure all the work are persistent.

Besides, when querying, the DbAction::EndAction may help to close the open result set, and do some other cleaning works.

Remember that, the library is only useful when rollback is trivial. As a result, I do not provide any methods about rollback. For systems which cannot reproduce the results by running the system again, this library is not recommended.

5. Disconnect
Disconnect from the DB(s).

Note that the EndAction and Disconnect will be automatically done by the de-constructor. But I recommend you to explicitly call them in codes.

***************************
About Batch INSERT/REPLACE operations
***************************
We can assign multiple values in a SQL INSERT, REPLACE(MYSQL)/MERGE INTO(DB2) statements such as
insert into ... values (...), (...), (...)
replace into ... values (...), (..), (...)
merge into ... using ( values(...), (...) ) ...

The library has provided some methods to easily handle these issues. Details can be found in the examples. In the codes, you do not need to implement the SQL statement, just providing columns names and there corresponding values. The library will component the statements related the underlying DB and send to the server as soon as the count of values are met the limits you have identified.

Unfortunately, the performance of batch operations are not good. After analysing by the result of gprof, too much time are wasted in the copy of column and values. In the future version, I will find better ways to handle them.
